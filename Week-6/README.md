# Week 6: Dynamic Programming

Welcome to Week 6 of the DSA Bootcamp 2025! After covering foundational topics like recursion and iterative problem solving, it's time to explore one of the most important concepts in algorithmic problem-solving: Dynamic Programming (DP).

This week, we will focus on understanding, identifying, and applying DP techniques to solve complex problems efficiently.

---

## Topics Covered

### Introduction to Dynamic Programming
We’ll begin by understanding what makes a problem suitable for DP:
- Overlapping subproblems
- Optimal substructure

You will learn two main approaches:
- Top-Down (Memoization)
- Bottom-Up (Tabulation)

We'll explore how DP evolves from naive recursion and how to optimize both time and space.

---

### Classic Problems
We will tackle some well-known DP problems, which will help you recognize patterns and apply them:
- Fibonacci Number Variants
- 0/1 Knapsack
- Subset Sum / Equal Partition
- Longest Common Subsequence (LCS)
- Longest Increasing Subsequence (LIS)

For each problem, you'll:
- Derive the recurrence relation
- Visualize the state space
- Implement both memoization and tabulation versions

---

### Patterns and Optimization
You'll also learn:
- Common DP problem patterns (like DP on subsequences, on grids, on partitions)
- When and how to use state compression to reduce space complexity
- Techniques for converting recursive solutions into iterative DP

---

## Practice
You will be solving selected LeetCode problems that reinforce the concepts discussed:
- Focus on building intuition behind the recurrence
- Write clean, structured DP solutions
- Learn to debug edge cases and optimize for constraints

---

## Final Notes
Dynamic Programming is a topic that often requires multiple passes for complete mastery. If it feels hard at first, that's normal — the key is to keep practicing and revisiting concepts until they click.

Use this week to build your foundation. The techniques you'll learn here will carry over into advanced algorithms and interview-level questions.

Stay consistent, focus on patterns, and make sure to reflect after solving each problem.

